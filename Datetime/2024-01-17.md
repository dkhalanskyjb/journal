Assorted questions about datetime
=================================

Formatting: how to interpret `yyyy`?
------------------------------------

```kotlin
byUnicodePattern("yyyy")
```

throws an `UnsupportedOperationException` because `y` is defined in terms of the
era, which depends on the calendar. Yet this directive is widely used.
What to do?

### Document a workaround

```kotlin
/**
 * ...
 *
 * For the ISO chronology and years 0001 and later, one can obtain results that are equivalent to `yyyy` and `yy` like
 * this: `byUnicodePattern(pattern.replace("yyyy", "uuuu").replace("yy", "uu")`.
 *
 * ...
 */
@FormatStringsInDatetimeFormats
public fun DateTimeFormatBuilder.byUnicodePattern(pattern: String)
```

Also, when an exception for `yyyy` is thrown, it says:

```
The locale-invariant ISO year directive 'uuuu' can be used instead.
```

Pros:

* For the use case of copy-pasting a string literal into Kotlin code, the person
  will just manually replace `yyyy` with `uuuu` and arrive at the correct
  solution (and maybe even learn something).
* For the use case of interpreting a string that arrives programmatically,
  the tradeoffs are clear.

Cons:

* Replacement is non-structural: in `"'No wayyy, it is ' yyyy"`, the string
  literal will be needlessly affected.
* The extra code with `replace` will be effectively always required for the use
  case of accepting strings from third parties.

### Convert slightly incorrectly

The default calendar is the ISO calendar, so unless the calendar was
explicitly overridden, `yyyy` and `uuuu` mean the same thing for years `1 AD`
and later. We can just pretend they are the same.

Risks:

* We do change the semantics for non-ISO calendars, like Japanese.
* We do change the semantics for years earlier than `1 AD`.


The risks are small: if `yyyy` is included and really means "year-of-era," we'll
fail anyway when asked to format the era. For example, "5年" means "the year 5,"
whereas "令和5年" means "the year 5 of the era of beautiful harmony."
If someone does format `yyyy` without mentioning the era, they probably don't
want `2024 AD` and `2024 BC` to be formatted indistinguishably.

Reward:

* No extra action required to use `byUnicodePattern` in most cases.

### Introduce new directives

Since the behavior of `yyyy` is in practice almost always the same as `uuuu` for
years `1 AD` and later, we can leverage that:

```kotlin
// throw when formatting ISO year < 1.
DateFormatBuilder.positiveYear()
DateFormatBuilder.positiveYearTwoDigits()
```

(or maybe extend the existing directives to support this functionality).

Then, we can convert `yyyy` to `positiveYear()` and
`yy` to `positiveYearTwoDigits()`.

Pros:

* No extra work needed to use `byUnicodePattern` for most of the common
  patterns that don't explicitly depend on locale-based directives.

Cons:

* Goes against the decision never to throw from formatting functions (as people
  are also using them for debugging, when arbitrary values can appear).
* Has the desired behavior for the default calendar in Java, but not for
  calendars that define other eras.

### Parameterize this behavior

`byUnicodePattern(pedantic = true)`, or just a separate function.

Pros:

* Those who want compliant behavior will get it.

Cons:

* It's unlikely that many people are interested in compliant behavior.

Formatting: trailing optional parts in `toString`
-------------------------------------------------

Issue: <https://github.com/Kotlin/kotlinx-datetime/issues/333>

Let's say you want to parse strings like these in Java:

```
23:59:59.999999999
14:48:20.066324610
01:16:15.144720800
... // and so on a few hundred times
06:34:00.000316310
```

They are all printed using `localTime.toString()`.

You use the format string `HH:mm:ss[.SSSSSSSSS]`, everything parses correctly,
the tests run with no problems.

You walk away happy, but then, in production, you see that the string
`17:15:08.542980` failed to parse.

The reason is, `toString()` pads the output so that the fractional part has a
multiple of three for a length:

```
01:02:03
01:02:03.100
01:02:03.120
01:02:03.123
01:02:03.123400
01:02:03.123450
01:02:03.123456
01:02:03.123456700
01:02:03.123456780
01:02:03.123456789
```

There's a 1/1000 chance that a random reading from `Clock.System.now()` will
show this behavior. Without adding trailing zeros, we'd increase the chance to
1/10.

This problem affects `toString()` today, but can also affect
`LocalTime.Formats.ISO` tomorrow.

We decided already that `LocalTime.Formats.ISO` should always include seconds,
even if they are zero, whereas `toString()` only includes seconds if they are
non-zero.

We don't expose the option to implement such a format from the datetime
formatting API, but do support it internally for the Native implementation of
`LocalTime.toString`.

* It's not a problem. Relying on a specific length of the fractional part is
  a recipe for problems anyway. On the other hand, grouping by three vastly
  improves readability. We should keep this behavior in `toString` and add it
  to `LocalTime.Formats.ISO`.
* It would be a problem for `LocalTime.Formats.ISO` but not for `toString`.
  Even though `toString` is paired with `parse`, it's primarily a human-readable
  representation, whereas `LocalTime.Formats.ISO` is mostly for interaction
  between computers. This is in line with outputting seconds optionally in
  `toString` but not `ISO`.
* It is a problem for both `ISO` and `toString`.
* In fact, `LocalTime.toString` should also avoid surprising users and always
  output the seconds.

Arithmetics: effect of the operation direction on the result resolution
-----------------------------------------------------------------------

**Note**: even if we think that the resolvers are coming soon, this section can
give us an interesting design constraint for them.

Let's say clock jumps directly from `02:00` to `03:00` on `Mar 31st`,
and from `03:00` back to `02:00` on `Oct 27th`.

* If we add one day to `2024-10-26T02:30` (when summer time is in effect), we
  end up at the earlier (also summer time) `02:30`.
* If we subtract one day from `2024-10-28T02:30`
  (when standard time is in effect), we end up at the later `02:30`
  (also standard time).

The idea behind this is to preserve the original offset.
This behavior may be counterintuitive in the following case:

* If we add 8 months to `2024-02-27T02:30` (when standard time is in effect),
  we end up at the *later* `02:30` (also standard time).
* If we subtract 6 months from `2025-04-27T02:30` (when summer time is in effect),
  we end up at the *earlier* `02:30` (also summer time).

The situation is even more murky if the timezone rules were changed at some
point. When adding a year or two in a timezone where UTC offsets were unstable
for some time, the result is essentially unpredictable.

Looks like the spirit of the behavior was to take *the direction* into account:
when coming from the future, try to stick to the offset that's later, and when
coming from the past, try to stay in the past.

It's interesting that this idea was *not* used when implementing traversals of
time gaps:

* If we add one day to `2024-03-30T02:24`, we get `2024-03-31T03:24`
  (that is, *24 minutes later than 2024-03-30T02:00*);
* If we subtract one day from `2024-04-01T02:24`, we also get
  `2024-03-31T03:24`. If we followed the logic of symmetry, we'd get
  `2024-03-31T01:24`, or *36 minutes earlier than 2024-03-30T03:00*.

Play:
<https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjIxIiwicGxhdGZvcm0iOiJqYXZhIiwiYXJncyI6IiIsIm5vbmVNYXJrZXJzIjp0cnVlLCJ0aGVtZSI6ImlkZWEiLCJjb2RlIjoiaW1wb3J0IGphdmEudGltZS4qXG5cbmZ1biBtYWluKCkge1xuICAgIHZhbCB6b25lID0gWm9uZUlkLm9mKFwiRXVyb3BlL0JlcmxpblwiKVxuICAgIHZhbCB0b1N1bW1lciA9IExvY2FsRGF0ZVRpbWUub2YoMjAyNCwgMywgMzEsIDMsIDAsIDAsIDApXG4gICAgdmFsIHRvU3RhbmRhcmQgPSBMb2NhbERhdGVUaW1lLm9mKDIwMjQsIDEwLCAyNywgMywgMCwgMCwgMClcbiAgICB0b1N0YW5kYXJkLm1pbnVzRGF5cygxKS5taW51c01pbnV0ZXMoMjQpLmF0Wm9uZSh6b25lKS5sZXQgeyBwcmludGxuKFwiJGl0ICsgMSBkYXkgPSAke2l0LnBsdXNEYXlzKDEpfVwiKSB9XG4gICAgIHRvU3RhbmRhcmQucGx1c0RheXMoMSkubWludXNNaW51dGVzKDI0KS5hdFpvbmUoem9uZSkubGV0IHsgcHJpbnRsbihcIiRpdCAtIDEgZGF5ID0gJHtpdC5taW51c0RheXMoMSl9XCIpIH1cbiAgICAgIHRvU3VtbWVyLm1pbnVzRGF5cygxKS5taW51c01pbnV0ZXMoMjQpLmF0Wm9uZSh6b25lKS5sZXQgeyBwcmludGxuKFwiJGl0ICsgMSBkYXkgPSAke2l0LnBsdXNEYXlzKDEpfVwiKSB9XG4gICAgICAgdG9TdW1tZXIucGx1c0RheXMoMSkubWludXNNaW51dGVzKDI0KS5hdFpvbmUoem9uZSkubGV0IHsgcHJpbnRsbihcIiRpdCAtIDEgZGF5ID0gJHtpdC5taW51c0RheXMoMSl9XCIpIH1cbn0ifQ==>

### Questions (in the abscence of resolvers)

#### Preserving the current offset VS taking the direction into account

For small adjustments, the two approaches yield the same results, but for
large ones, it's not clear why one would want to stick to the offset that's
been irrelevant for a long time.

#### Symmetry

When we traverse the time gap backwards, should we subtract time from the moment
of the time gap (for symmetry), or should we add time to the gap where we landed
after the subtraction (the way both we and Java do now)?

#### Composite operations

"Add a month and subtract a day."

* Intuitively, the direction is forward.
* We define `DateTimePeriod` operation as "first months, then days, then
  nanoseconds are applied," which means that the direction of the last operation
  is *backwards*.
* By the ISO 8601, adding a month is adding a number of calendar days defined by
  the calendar, which means the direction *is* forward after all.

"Add a month and subtract 30 days."

This may be a forward operation when applied in a month with 31 days, but it's
clearly a backward operation when applied to a month with 29 days.

### Questions (related to resolvers)

If someone wants to interpret gaps and overlaps in terms of what direction we're
coming from, the logic should be roughly this:

```kotlin
plus(1, DateTimeUnit.DAY, Resolver.FORWARD)
plus(-1, DateTimeUnit.DAY, Resolver.BACKWARD)
minus(1, DateTimeUnit.DAY, Resolver.BACKWARD)
minus(-1, DateTimeUnit.DAY, Resolver.FORWARD)
```

It's a bit cumbersome to implement, especially for composite operations, whose
direction is tricky to define and may even depend on the input date.
