Entities to format
------------------

The most popular requests:

* `Instant`
* `LocalDateTime`
* `LocalDateTime` + an offset specification.

The other entities to format:

* `LocalDate`
* `LocalTime` (doesn’t exist yet, but need to keep it in mind)
* `TimeZone`
* `UtcOffset`
* `DateTimePeriod`

Per-entity discussion
---------------------

### Instant

For all targets, we define the admissible range of `Instant` to be one year
wider than that of `LocalDateTime`.
Because of this, using `LocalDateTime` formatter for `Instant` is non-trivial.

* This can be mitigated boldly and by making `LocalDateTime` wider than
  `Instant`, with the added bonus being that `Instant.toLocalDateTime` will
  never, ever fail, which would make `TimeZone` equivalent to a total function
  from `Instant` to `LocalDateTime`, which is semantically pleasing.
  In fact, do we even want to define an upper bound on the number of years
  in `LocalDate` that’s not implied by the type?
* If, as described below in the section about format strings, parsing returns
  `null` as component values by default, and formatting `LocalDateTime` is
  possible without constructing one, everything works out on its own.

### LocalDateTime

Any combination of valid `LocalDate` and `LocalTime` is a valid `LocalDateTime`,
so their issues are also relevant here.

The issues specific to `LocalDateTime`:

* Sometimes the order is reversed, and time comes first, so we can’t just do
  anything akin to the following and just chain the formatters together:
```
fun LocalDateTime.formatter(
  dateFormatter: Formatter<LocalDate>,
  timeFormatter: Formatter<LocalTime>
): Formatter<LocalDateTime>
```
and chain the time formatter after the date formatter.
* Moreover, there exist some formats that intermingle time and date components.
  A naive search for such formats yielded `mingling_components.txt`.
  Despite several false positives and some obvious mistakes like `dd-mm-yyyy`,
  there are clearly formats that do intermingle the components intentionally,
  like `EEE MMM dd HH:mm:ss zzz yyyy`.
  This string seems important: dates of such format are generated by
  `java.util.Date.toString()`.
  See the `hasMinglingComponents` function.
* Darwin supports formatting date and time relative to some other `LocalDateTime`
  taken to be the current moment, like “today”, “yesterday”, “today at 16:45”,
  or “2 hours ago”:
  <https://developer.apple.com/documentation/foundation/relativedatetimeformatter>.
  * Heavily relies on localization, and it's unclear where to grab all these
    strings.

### OffsetDateTime/ZonedDateTime

Options:

* Define a separate class for these to be able to parse/format everything.
* Use chaining and do as you please:

```
val instantWithOffsetFmt =
  LocalDateTime.Formatters.iso8601.chain(UtcOffset.Formatters.iso8601, { ldt, offset ->
    ldt.toInstant(offset)
  }, { init, instant ->
    init(instant.toLocalDateTime(TimeZone.UTC), UtcOffset.ZERO)
  })
```

### LocalDate

* When the pattern expects a two-digit year, what range do we assume the year
  to be in?
* Sometimes Roman numerals are needed for representing months.
  See the discussion of the grammatical cases below.
* The concept of eras, also typically localized.
  There are long and short forms of eras.
  Supported by most other libraries, it seems.
* Customizable behavior for years below 1: does year 0 exist, or does it become
  -1, or does it become 1, but the era changes?
* A lot of libraries support week-years, where the components are not
  year-month-day, but year’-week-day’.
  At least this is needed in some form if we are to output day-of-week.
    * If we output day-of-week values by name, this also needs to be localized.
* Localized month names. See below.
* Grammatical cases. For example, “январь 2021”, but “21 января 2021”.
  * Can be mitigated *completely* if we just allow providing an argument with
    the month names to use. This also solves the need for short month names,
    long month names, roman numeral names, localized month names, etc.,
    if we just provide a DIY set of lists of month names.
* To parse and format ISO-8601, we need to be able to express that,
  when there are more than four digits, a sign must be included.
* Month and day numbers must support a leading zero.

### LocalTime

* Two forms: 24-hour, and 12-hour with AM/PM.
* AM/PM could need to be custom.
    * How to specify them?
    * How do we access the localized versions?
* A clean solution for fractional seconds is unclear: someone could want,
  for example, to output parts of the fraction, splitting by three.
  It seems though that everyone just converged to using a generic
  “fraction of a second” modifier.
  * Also, fractional delimiter is locale-dependent
    (though it should be easy to acquire), just as the separator for grouping
    digits together.
* It is common to need to parse/format without the trailing zeros.
  For example, ISO-8601 does this.
* It is often required to have output or parse `am`/`pm` or `AM`/`PM`.

### TimeZone

* Time zones have short and long names.
* Time zones are sometimes formatted with the DST flag,
  which we don’t recognize at all.
* There are custom names for time zones. (RFC-833?..)
* Time zones may have localized names:
  <http://unicode.org/reports/tr35/tr35-6.html#Time_Zone_Fallback>

### UtcOffset

There are several orthogonal dimensions here:
* Whether or not to require `:` between the components: `03:00` vs `0300`.
* Whether or not to represent `00:00` as `Z`.
* How many components to print.

The systems we're looking at don't define the offset format pattens to be
sets of components at all. There are good reasons for this:
* There's probably never a reason to reorder the components.
* There's probably never a reason to round the components.
* A style chosen for one component probably should apply to all the other
  components.
* Offsets have a sign that negates the offset as a whole, not just the hour
  component.

It is certainly nice to have a system where we can express the rules for
formatting the offset like `%+%02h(:%02m(:%02s|)|)|Z`, but, regardless of
whether we end up allowing writing such patterns manually, we'll need to
provide predefined patterns for offsets in any case.

### DateTimePeriod

* See `LocalTime` for a discussion on outputting fractional seconds.
* It’s unclear what to do with error-proneness of cutting values off at
  a certain point. For example, how to make a nonsensical query
  “total amount of hours, total amount of minutes, seconds-of-a-minute”
  non-representable while preserving the valid use cases.
* Do we ever want to parse this, or just to format?
